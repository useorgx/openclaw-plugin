<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>OrgX Live</title>
    <meta
      http-equiv="Content-Security-Policy"
      content="default-src 'none'; img-src data: https:; style-src 'unsafe-inline'; script-src 'unsafe-inline'; connect-src *;"
    />
    <style>
      :root {
        --bg: #0b0d12;
        --panel: #121625;
        --panel2: #0f1320;
        --border: rgba(255, 255, 255, 0.1);
        --text: rgba(255, 255, 255, 0.92);
        --muted: rgba(255, 255, 255, 0.65);
        --muted2: rgba(255, 255, 255, 0.5);
        --accent: #7c5cff;
        --accent2: #23d2aa;
        --warn: #ffcc66;
        --bad: #ff5c7a;
        --good: #2cffb0;
        --shadow: rgba(0, 0, 0, 0.55);
        --radius: 14px;
        --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          "Liberation Mono", "Courier New", monospace;
        --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto,
          Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      }

      html,
      body {
        height: 100%;
        margin: 0;
        padding: 0;
        background: radial-gradient(
            900px 520px at 20% 10%,
            rgba(124, 92, 255, 0.16),
            rgba(0, 0, 0, 0)
          ),
          radial-gradient(
            800px 440px at 80% 0%,
            rgba(35, 210, 170, 0.12),
            rgba(0, 0, 0, 0)
          ),
          linear-gradient(180deg, #07080c, var(--bg));
        color: var(--text);
        font-family: var(--sans);
      }

      a {
        color: inherit;
        text-decoration: none;
      }

      .wrap {
        max-width: 980px;
        margin: 0 auto;
        padding: 18px;
      }

      .top {
        display: flex;
        align-items: flex-start;
        justify-content: space-between;
        gap: 16px;
        padding: 16px 16px 14px 16px;
        border: 1px solid var(--border);
        border-radius: var(--radius);
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.05),
          rgba(255, 255, 255, 0.02)
        );
        box-shadow: 0 16px 40px var(--shadow);
      }

      .brand {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }

      .title {
        font-size: 18px;
        font-weight: 760;
        letter-spacing: -0.02em;
        display: flex;
        align-items: baseline;
        gap: 10px;
      }

      .badge {
        font-family: var(--mono);
        font-size: 12px;
        color: var(--muted);
        border: 1px solid var(--border);
        border-radius: 999px;
        padding: 2px 8px;
        background: rgba(0, 0, 0, 0.2);
      }

      .sub {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        font-size: 12px;
        color: var(--muted);
      }

      .pill {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 6px 10px;
        border-radius: 999px;
        border: 1px solid var(--border);
        background: rgba(0, 0, 0, 0.2);
      }

      .dot {
        width: 8px;
        height: 8px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.25);
      }

      .dot.good {
        background: var(--good);
      }
      .dot.warn {
        background: var(--warn);
      }
      .dot.bad {
        background: var(--bad);
      }

      .actions {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        justify-content: flex-end;
      }

      button {
        font: inherit;
        color: var(--text);
        border: 1px solid var(--border);
        background: rgba(0, 0, 0, 0.2);
        border-radius: 12px;
        padding: 10px 12px;
        cursor: pointer;
        transition: transform 120ms ease, background 120ms ease,
          border-color 120ms ease;
      }

      button:hover {
        background: rgba(255, 255, 255, 0.06);
        border-color: rgba(255, 255, 255, 0.22);
        transform: translateY(-1px);
      }

      button.primary {
        background: linear-gradient(
          90deg,
          rgba(124, 92, 255, 0.9),
          rgba(35, 210, 170, 0.75)
        );
        border-color: rgba(255, 255, 255, 0.22);
      }

      .grid {
        display: grid;
        grid-template-columns: repeat(12, 1fr);
        gap: 14px;
        margin-top: 14px;
      }

      .card {
        grid-column: span 12;
        border: 1px solid var(--border);
        border-radius: var(--radius);
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.05),
          rgba(255, 255, 255, 0.02)
        );
        box-shadow: 0 10px 26px rgba(0, 0, 0, 0.45);
        overflow: hidden;
      }

      .card h2 {
        margin: 0;
        padding: 12px 14px;
        font-size: 13px;
        letter-spacing: 0.02em;
        color: rgba(255, 255, 255, 0.76);
        text-transform: uppercase;
        border-bottom: 1px solid var(--border);
        background: rgba(0, 0, 0, 0.18);
      }

      .card .body {
        padding: 12px 14px 14px 14px;
      }

      .list {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      .row {
        display: flex;
        align-items: flex-start;
        justify-content: space-between;
        gap: 12px;
        border: 1px solid var(--border);
        border-radius: 12px;
        background: linear-gradient(180deg, var(--panel), var(--panel2));
        padding: 10px 12px;
      }

      .row .left {
        min-width: 0;
      }

      .row .right {
        flex: 0 0 auto;
        display: flex;
        gap: 10px;
        align-items: center;
        color: var(--muted2);
        font-family: var(--mono);
        font-size: 12px;
        white-space: nowrap;
      }

      .row .name {
        font-weight: 650;
        letter-spacing: -0.01em;
        line-height: 1.2;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        max-width: 100%;
      }

      .row .meta {
        margin-top: 6px;
        font-size: 12px;
        color: var(--muted);
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }

      .tag {
        font-family: var(--mono);
        font-size: 11px;
        border: 1px solid var(--border);
        border-radius: 999px;
        padding: 2px 8px;
        background: rgba(0, 0, 0, 0.16);
        color: rgba(255, 255, 255, 0.78);
      }

      .empty {
        color: var(--muted);
        font-size: 13px;
        padding: 8px 2px;
      }

      .error {
        border: 1px solid rgba(255, 92, 122, 0.35);
        background: rgba(255, 92, 122, 0.08);
        color: rgba(255, 255, 255, 0.9);
        border-radius: 12px;
        padding: 12px;
        font-family: var(--mono);
        font-size: 12px;
        white-space: pre-wrap;
      }

      @media (min-width: 860px) {
        .card.split {
          grid-column: span 6;
        }
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="top">
        <div class="brand">
          <div class="title">
            OrgX Live
            <span class="badge">plugin __ORGX_PLUGIN_VERSION__</span>
          </div>
          <div class="sub">
            <span class="pill"
              ><span id="connDot" class="dot warn"></span
              ><span id="connLabel">Connecting...</span></span
            >
            <span class="pill"
              ><span class="dot"></span
              ><span id="syncedAt">No snapshot yet</span></span
            >
          </div>
        </div>
        <div class="actions">
          <button id="refreshBtn" class="primary" type="button">Refresh</button>
          <button id="openDashBtn" type="button">Open OrgX Live</button>
          <button id="openDocsBtn" type="button">Docs</button>
        </div>
      </div>

      <div class="grid">
        <section class="card split">
          <h2>Initiatives</h2>
          <div class="body">
            <div id="initiatives" class="list"></div>
          </div>
        </section>

        <section class="card split">
          <h2>Agents</h2>
          <div class="body">
            <div id="agents" class="list"></div>
          </div>
        </section>

        <section class="card split">
          <h2>Active Tasks</h2>
          <div class="body">
            <div id="tasks" class="list"></div>
          </div>
        </section>

        <section class="card split">
          <h2>Pending Decisions</h2>
          <div class="body">
            <div id="decisions" class="list"></div>
          </div>
        </section>

        <section class="card">
          <h2>Raw</h2>
          <div class="body">
            <div id="raw" class="error" style="display: none"></div>
            <div id="hint" class="empty">
              This app calls back into the host via MCP Apps postMessage, then
              reads OrgX state via <span class="tag">tools/call</span>.
            </div>
          </div>
        </section>
      </div>
    </div>

    <script>
      (() => {
        const PROTOCOL_VERSION = "2026-01-26";
        const APP_REQUEST_MESSAGE_TYPE = "mcp/app/request";
        const APP_RESPONSE_MESSAGE_TYPE = "mcp/app/response";
        const APP_NOTIFICATION_MESSAGE_TYPE = "mcp/app/notification";
        const CHANNEL_ID_PARAM = "mcp-app-channel-id";

        const INITIALIZE_METHOD = "ui/initialize";
        const TOOL_CALL_METHOD = "tools/call";
        const HOST_CONTEXT_CHANGED_METHOD = "ui/hostContextChanged";

        const qs = new URLSearchParams(window.location.search);
        const channelId = qs.get(CHANNEL_ID_PARAM) || null;

        const el = {
          connDot: document.getElementById("connDot"),
          connLabel: document.getElementById("connLabel"),
          syncedAt: document.getElementById("syncedAt"),
          refreshBtn: document.getElementById("refreshBtn"),
          openDashBtn: document.getElementById("openDashBtn"),
          openDocsBtn: document.getElementById("openDocsBtn"),
          initiatives: document.getElementById("initiatives"),
          agents: document.getElementById("agents"),
          tasks: document.getElementById("tasks"),
          decisions: document.getElementById("decisions"),
          raw: document.getElementById("raw"),
          hint: document.getElementById("hint"),
        };

        function setConn(kind, label) {
          el.connLabel.textContent = label;
          el.connDot.className = `dot ${kind}`;
        }

        function setSyncedAt(value) {
          el.syncedAt.textContent = value || "No snapshot yet";
        }

        function safeText(value) {
          if (value == null) return "";
          return String(value);
        }

        function clear(node) {
          while (node.firstChild) node.removeChild(node.firstChild);
        }

        function row(title, tags, rightText) {
          const root = document.createElement("div");
          root.className = "row";

          const left = document.createElement("div");
          left.className = "left";

          const name = document.createElement("div");
          name.className = "name";
          name.textContent = title;

          const meta = document.createElement("div");
          meta.className = "meta";
          for (const t of tags) {
            const tag = document.createElement("span");
            tag.className = "tag";
            tag.textContent = t;
            meta.appendChild(tag);
          }

          left.appendChild(name);
          if (tags.length) left.appendChild(meta);

          const right = document.createElement("div");
          right.className = "right";
          right.textContent = rightText || "";

          root.appendChild(left);
          root.appendChild(right);
          return root;
        }

        function empty(text) {
          const d = document.createElement("div");
          d.className = "empty";
          d.textContent = text;
          return d;
        }

        function showRaw(value) {
          const text =
            typeof value === "string" ? value : JSON.stringify(value, null, 2);
          el.raw.style.display = "block";
          el.raw.textContent = text;
        }

        function hideRaw() {
          el.raw.style.display = "none";
          el.raw.textContent = "";
        }

        function randomId() {
          if (typeof crypto !== "undefined" && crypto.randomUUID) {
            return crypto.randomUUID();
          }
          return `${Date.now()}-${Math.random().toString(16).slice(2)}`;
        }

        const pending = new Map();

        function postEnvelope(message) {
          window.parent.postMessage(message, "*");
        }

        function request(method, params, timeoutMs = 30_000) {
          return new Promise((resolve, reject) => {
            const id = randomId();
            const timer = setTimeout(() => {
              pending.delete(id);
              reject(new Error(`timeout waiting for ${method}`));
            }, timeoutMs);

            pending.set(id, { resolve, reject, timer });

            const envelope = {
              protocolVersion: PROTOCOL_VERSION,
              messageType: APP_REQUEST_MESSAGE_TYPE,
              request: {
                jsonrpc: "2.0",
                id,
                method,
                params,
              },
            };

            if (channelId) envelope.channelId = channelId;
            postEnvelope(envelope);
          });
        }

        function handleNotification(notification) {
          if (!notification || typeof notification !== "object") return;
          if (notification.method === HOST_CONTEXT_CHANGED_METHOD) {
            const theme = notification.params && notification.params.theme;
            if (theme && typeof theme === "object") {
              // Host theme is optional; we keep our own styling for now.
            }
          }
        }

        function onMessage(event) {
          const msg = event.data;
          if (!msg || typeof msg !== "object") return;

          if (channelId && msg.channelId && msg.channelId !== channelId) {
            return;
          }

          if (msg.messageType === APP_RESPONSE_MESSAGE_TYPE && msg.response) {
            const id = msg.response.id;
            const slot = pending.get(id);
            if (!slot) return;
            pending.delete(id);
            clearTimeout(slot.timer);
            if (msg.response.error) {
              slot.reject(new Error(msg.response.error.message || "error"));
            } else {
              slot.resolve(msg.response.result);
            }
            return;
          }

          if (
            msg.messageType === APP_NOTIFICATION_MESSAGE_TYPE &&
            msg.notification
          ) {
            handleNotification(msg.notification);
          }
        }

        window.addEventListener("message", onMessage);

        async function initialize() {
          const result = await request(INITIALIZE_METHOD, {
            protocolVersion: PROTOCOL_VERSION,
            clientInfo: {
              name: "OrgX Live (OpenClaw Plugin)",
              version: "__ORGX_PLUGIN_VERSION__",
            },
          });
          return result;
        }

        async function callTool(name, args) {
          return request(TOOL_CALL_METHOD, { name, arguments: args || {} });
        }

        function extractText(toolResult) {
          const content = toolResult && toolResult.content;
          if (!Array.isArray(content)) return "";
          for (const item of content) {
            if (!item || typeof item !== "object") continue;
            if (item.type === "text" && typeof item.text === "string") {
              return item.text;
            }
          }
          return "";
        }

        function renderStatus(statusJson) {
          const baseUrl = statusJson && statusJson.baseUrl;
          const docsUrl = statusJson && statusJson.docsUrl;
          const snap = statusJson && statusJson.snapshot;

          el.openDashBtn.disabled = !baseUrl;
          el.openDocsBtn.disabled = !docsUrl;
          el.openDashBtn.onclick = () => {
            if (!baseUrl) return;
            window.open(`${baseUrl.replace(/\\/+$/, "")}/live`, "_blank");
          };
          el.openDocsBtn.onclick = () => {
            if (!docsUrl) return;
            window.open(docsUrl, "_blank");
          };

          setSyncedAt((snap && snap.syncedAt) || "");

          clear(el.initiatives);
          const initiatives = (snap && snap.initiatives) || [];
          if (!initiatives.length) {
            el.initiatives.appendChild(empty("No initiatives in snapshot."));
          } else {
            for (const init of initiatives.slice(0, 8)) {
              const pct =
                init.progress == null ? "" : `${Math.round(init.progress)}%`;
              const tags = [];
              if (init.status) tags.push(safeText(init.status));
              if (pct) tags.push(pct);
              el.initiatives.appendChild(
                row(init.title || init.id || "Untitled", tags, init.id || "")
              );
            }
          }

          clear(el.agents);
          const agents = (snap && snap.agents) || [];
          if (!agents.length) {
            el.agents.appendChild(empty("No agents in snapshot."));
          } else {
            for (const a of agents.slice(0, 10)) {
              const tags = [];
              if (a.domain) tags.push(safeText(a.domain));
              if (a.status) tags.push(safeText(a.status));
              if (a.currentTask) tags.push(`task: ${safeText(a.currentTask)}`);
              el.agents.appendChild(
                row(a.name || a.id || "Agent", tags, a.id || "")
              );
            }
          }

          clear(el.tasks);
          const tasks = (snap && snap.activeTasks) || [];
          if (!tasks.length) {
            el.tasks.appendChild(empty("No active tasks in snapshot."));
          } else {
            for (const t of tasks.slice(0, 10)) {
              const tags = [];
              if (t.status) tags.push(safeText(t.status));
              if (t.domain) tags.push(safeText(t.domain));
              if (t.modelTier) tags.push(safeText(t.modelTier));
              el.tasks.appendChild(
                row(t.title || t.id || "Task", tags, t.id || "")
              );
            }
          }

          clear(el.decisions);
          const decisions = (snap && snap.pendingDecisions) || [];
          if (!decisions.length) {
            el.decisions.appendChild(empty("No pending decisions."));
          } else {
            for (const d of decisions.slice(0, 10)) {
              const tags = [];
              if (d.urgency) tags.push(`urgency: ${safeText(d.urgency)}`);
              el.decisions.appendChild(
                row(d.title || d.id || "Decision", tags, d.id || "")
              );
            }
          }
        }

        async function refresh() {
          hideRaw();
          el.refreshBtn.disabled = true;
          el.refreshBtn.textContent = "Refreshing...";
          try {
            const toolResult = await callTool("orgx_status_json", {});
            const rawText = extractText(toolResult);
            const statusJson = rawText ? JSON.parse(rawText) : null;
            if (!statusJson || !statusJson.snapshot) {
              showRaw(toolResult);
              throw new Error("unexpected response");
            }
            renderStatus(statusJson);
          } finally {
            el.refreshBtn.disabled = false;
            el.refreshBtn.textContent = "Refresh";
          }
        }

        async function boot() {
          try {
            setConn("warn", "Initializing...");
            await initialize();
            setConn("good", "Connected");
            el.refreshBtn.addEventListener("click", refresh);
            await refresh();
          } catch (err) {
            setConn("bad", "Failed");
            showRaw(
              err instanceof Error ? `${err.name}: ${err.message}` : String(err)
            );
          }
        }

        boot();
      })();
    </script>
  </body>
</html>

