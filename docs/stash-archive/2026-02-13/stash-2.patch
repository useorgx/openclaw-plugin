diff --git a/src/http-handler.ts b/src/http-handler.ts
index 60e005a..9ff9ca2 100644
--- a/src/http-handler.ts
+++ b/src/http-handler.ts
@@ -16,7 +16,14 @@
  *   /orgx/api/runs/:id/actions/:action â†’ run control action
  */
 
-import { readFileSync, existsSync, mkdirSync } from "node:fs";
+import {
+  chmodSync,
+  createWriteStream,
+  existsSync,
+  mkdirSync,
+  readFileSync,
+  writeFileSync,
+} from "node:fs";
 import { homedir } from "node:os";
 import { join, extname, normalize, resolve, relative, sep, dirname } from "node:path";
 import { fileURLToPath } from "node:url";
@@ -3370,6 +3377,74 @@ export function createHttpHandler(
   let autoContinueTickInFlight = false;
   const AUTO_CONTINUE_TICK_MS = 2_500;
 
+  // ---------------------------------------------------------------------------
+  // Auto-continue v2 (Workstream Slices)
+  //
+  // Dispatches sets of work (a "slice") for a workstream and expects verifiable
+  // outcomes that can be registered as OrgX artifacts + decisions.
+  //
+  // Important: we do NOT auto-mark OrgX tasks/initiatives as done. Status changes
+  // are only applied when explicitly requested by the executing agent.
+  // ---------------------------------------------------------------------------
+
+  const AUTO_CONTINUE_SLICE_MAX_TASKS = 6;
+  const AUTO_CONTINUE_SLICE_TIMEOUT_MS = 55 * 60_000;
+  const AUTO_CONTINUE_SLICE_HEARTBEAT_MS = 12_000;
+  const AUTO_CONTINUE_SLICE_SCHEMA_FILENAME = "autopilot-slice-schema.json";
+  const AUTO_CONTINUE_SLICE_LOG_DIRNAME = "autopilot-logs";
+
+  type AutoContinueSliceStatus = "running" | "completed" | "blocked" | "error";
+  type AutoContinueSliceDecision = {
+    question: string;
+    summary?: string | null;
+    options?: string[] | null;
+    urgency?: "low" | "medium" | "high" | "urgent";
+    blocking?: boolean | null;
+  };
+  type AutoContinueSliceArtifact = {
+    name: string;
+    artifact_type?: string | null;
+    description?: string | null;
+    url?: string | null;
+    verification_steps?: string[] | null;
+    milestone_id?: string | null;
+    task_ids?: string[] | null;
+  };
+  type AutoContinueSliceResult = {
+    status: "completed" | "blocked" | "needs_decision" | "error";
+    summary: string;
+    artifacts?: AutoContinueSliceArtifact[] | null;
+    decisions_needed?: AutoContinueSliceDecision[] | null;
+    task_updates?: Array<{ task_id: string; status: string; reason?: string | null }> | null;
+    milestone_updates?: Array<{ milestone_id: string; status: string; reason?: string | null }> | null;
+    next_actions?: string[] | null;
+  };
+  type AutoContinueSliceRun = {
+    runId: string;
+    initiativeId: string;
+    initiativeTitle: string | null;
+    workstreamId: string;
+    workstreamTitle: string | null;
+    agentId: string;
+    agentName: string | null;
+    domain: string;
+    requiredSkills: string[];
+    pid: number | null;
+    status: AutoContinueSliceStatus;
+    startedAt: string;
+    finishedAt: string | null;
+    updatedAt: string;
+    tokenEstimate: number | null;
+    outputPath: string;
+    logPath: string;
+    taskIds: string[];
+    milestoneIds: string[];
+    lastError: string | null;
+  };
+
+  const autoContinueSliceRuns = new Map<string, AutoContinueSliceRun>();
+  const autoContinueSliceLastHeartbeatMs = new Map<string, number>();
+
   const setLocalInitiativeStatusOverride = (
     initiativeId: string,
     status: string
@@ -3688,6 +3763,527 @@ export function createHttpHandler(
     }
   }
 
+  function ensurePrivateDirForFile(pathname: string): void {
+    const dir = dirname(pathname);
+    mkdirSync(dir, { recursive: true, mode: 0o700 });
+    try {
+      chmodSync(dir, 0o700);
+    } catch {
+      // best effort
+    }
+  }
+
+  function autopilotSliceSchema(): Record<string, unknown> {
+    // Strict enough to keep outputs predictable, but tolerant of agents that omit optional fields.
+    return {
+      type: "object",
+      additionalProperties: false,
+      required: ["status", "summary"],
+      properties: {
+        status: {
+          type: "string",
+          enum: ["completed", "blocked", "needs_decision", "error"],
+        },
+        summary: { type: "string", minLength: 1 },
+        artifacts: {
+          type: ["array", "null"],
+          items: {
+            type: "object",
+            additionalProperties: false,
+            required: ["name"],
+            properties: {
+              name: { type: "string", minLength: 1 },
+              artifact_type: { type: ["string", "null"] },
+              description: { type: ["string", "null"] },
+              url: { type: ["string", "null"] },
+              verification_steps: {
+                type: ["array", "null"],
+                items: { type: "string" },
+              },
+              milestone_id: { type: ["string", "null"] },
+              task_ids: { type: ["array", "null"], items: { type: "string" } },
+            },
+          },
+        },
+        decisions_needed: {
+          type: ["array", "null"],
+          items: {
+            type: "object",
+            additionalProperties: false,
+            required: ["question"],
+            properties: {
+              question: { type: "string", minLength: 1 },
+              summary: { type: ["string", "null"] },
+              options: { type: ["array", "null"], items: { type: "string" } },
+              urgency: {
+                type: ["string", "null"],
+                enum: ["low", "medium", "high", "urgent", null],
+              },
+              blocking: { type: ["boolean", "null"] },
+            },
+          },
+        },
+        task_updates: {
+          type: ["array", "null"],
+          items: {
+            type: "object",
+            additionalProperties: false,
+            required: ["task_id", "status"],
+            properties: {
+              task_id: { type: "string", minLength: 1 },
+              status: { type: "string", minLength: 1 },
+              reason: { type: ["string", "null"] },
+            },
+          },
+        },
+        milestone_updates: {
+          type: ["array", "null"],
+          items: {
+            type: "object",
+            additionalProperties: false,
+            required: ["milestone_id", "status"],
+            properties: {
+              milestone_id: { type: "string", minLength: 1 },
+              status: { type: "string", minLength: 1 },
+              reason: { type: ["string", "null"] },
+            },
+          },
+        },
+        next_actions: { type: ["array", "null"], items: { type: "string" } },
+      },
+    };
+  }
+
+  function ensureAutopilotSliceSchemaPath(): string {
+    const file = join(getOrgxPluginConfigDir(), AUTO_CONTINUE_SLICE_SCHEMA_FILENAME);
+    try {
+      if (existsSync(file)) return file;
+      ensurePrivateDirForFile(file);
+      writeFileAtomicSync(file, JSON.stringify(autopilotSliceSchema(), null, 2), { mode: 0o600 });
+      return file;
+    } catch {
+      try {
+        ensurePrivateDirForFile(file);
+        writeFileSync(file, `${JSON.stringify(autopilotSliceSchema(), null, 2)}\n`, {
+          encoding: "utf8",
+          mode: 0o600,
+        });
+      } catch {
+        // ignore
+      }
+      return file;
+    }
+  }
+
+  function parseSliceResult(raw: string): AutoContinueSliceResult | null {
+    const trimmed = raw.trim();
+    if (!trimmed) return null;
+    const direct = parseJsonSafe<AutoContinueSliceResult>(trimmed);
+    if (direct && typeof direct === "object") return direct;
+    const first = trimmed.lastIndexOf("{");
+    const last = trimmed.lastIndexOf("}");
+    if (first >= 0 && last > first) {
+      const candidate = trimmed.slice(first, last + 1);
+      const parsed = parseJsonSafe<AutoContinueSliceResult>(candidate);
+      if (parsed && typeof parsed === "object") return parsed;
+    }
+    return null;
+  }
+
+  function readSliceOutputFile(pathname: string): string | null {
+    try {
+      if (!existsSync(pathname)) return null;
+      const raw = readFileSync(pathname, "utf8");
+      return raw.trim().length > 0 ? raw : null;
+    } catch {
+      return null;
+    }
+  }
+
+  function normalizeCodexArgs(args: string[]): string[] {
+    const normalized = Array.isArray(args) ? [...args] : [];
+    const first = normalized[0];
+    const looksLikeFlag = typeof first === "string" && first.startsWith("-");
+    const looksLikeCommand =
+      first === "exec" ||
+      first === "e" ||
+      first === "review" ||
+      first === "resume" ||
+      first === "help" ||
+      first === "features" ||
+      first === "mcp" ||
+      first === "mcp-server" ||
+      first === "app" ||
+      first === "app-server" ||
+      first === "debug" ||
+      first === "cloud";
+
+    if (!looksLikeCommand || looksLikeFlag) {
+      normalized.unshift("exec");
+    }
+    if (!normalized.includes("--skip-git-repo-check")) {
+      normalized.push("--skip-git-repo-check");
+    }
+    if (!normalized.some((arg) => String(arg).includes("model_reasoning_effort"))) {
+      normalized.push("-c", 'model_reasoning_effort="high"');
+    }
+    return normalized;
+  }
+
+  function spawnCodexSliceWorker(input: {
+    runId: string;
+    prompt: string;
+    cwd: string;
+    logPath: string;
+    outputPath: string;
+    env: Record<string, string | undefined>;
+  }): { pid: number | null } {
+    ensurePrivateDirForFile(input.logPath);
+    ensurePrivateDirForFile(input.outputPath);
+
+    const codexBin = (process.env.ORGX_CODEX_BIN ?? "").trim() || "codex";
+    const rawArgs = (process.env.ORGX_CODEX_ARGS ?? "").trim();
+    const args = normalizeCodexArgs(
+      rawArgs.length > 0 ? rawArgs.split(/\s+/).filter(Boolean) : ["--full-auto"]
+    );
+
+    const logStream = createWriteStream(input.logPath, { flags: "a" });
+    const outStream = createWriteStream(input.outputPath, { flags: "a" });
+    logStream.write(`\n==== ${new Date().toISOString()} :: slice ${input.runId} ====\n`);
+
+    const child = spawn(codexBin, [...args, input.prompt], {
+      cwd: input.cwd,
+      env: {
+        ...process.env,
+        ...resolveByokEnvOverrides(),
+        ...input.env,
+      },
+      stdio: ["ignore", "pipe", "pipe"],
+      detached: true,
+    });
+
+    child.stdout?.on("data", (chunk) => {
+      try {
+        logStream.write(chunk);
+      } catch {
+        // ignore
+      }
+      try {
+        outStream.write(chunk);
+      } catch {
+        // ignore
+      }
+    });
+    child.stderr?.on("data", (chunk) => {
+      try {
+        logStream.write(chunk);
+      } catch {
+        // ignore
+      }
+    });
+
+    child.on("close", (code, signal) => {
+      const stamp = new Date().toISOString();
+      try {
+        logStream.write(`\n==== ${stamp} :: exit code=${String(code)} signal=${String(signal)} ====\n`);
+      } catch {
+        // ignore
+      }
+      try {
+        logStream.end();
+      } catch {
+        // ignore
+      }
+      try {
+        outStream.end();
+      } catch {
+        // ignore
+      }
+    });
+    child.on("error", (error) => {
+      try {
+        logStream.write(`\nworker error: ${safeErrorMessage(error)}\n`);
+      } catch {
+        // ignore
+      }
+    });
+
+    child.unref();
+    return { pid: child.pid ?? null };
+  }
+
+  function writeRuntimeEvent(input: {
+    sourceClient: RuntimeSourceClient;
+    event: RuntimeHookPayload["event"];
+    runId: string;
+    initiativeId: string;
+    workstreamId: string | null;
+    taskId: string | null;
+    agentId: string | null;
+    agentName: string | null;
+    phase: string | null;
+    message?: string | null;
+    progressPct?: number | null;
+    metadata?: Record<string, unknown> | null;
+    timestamp?: string | null;
+  }): RuntimeInstanceRecord {
+    const instance = upsertRuntimeInstanceFromHook({
+      source_client: input.sourceClient,
+      event: input.event ?? null,
+      run_id: input.runId,
+      correlation_id: input.runId,
+      initiative_id: input.initiativeId,
+      workstream_id: input.workstreamId,
+      task_id: input.taskId,
+      agent_id: input.agentId,
+      agent_name: input.agentName,
+      phase: input.phase,
+      progress_pct: input.progressPct ?? null,
+      message: input.message ?? null,
+      metadata: input.metadata ?? null,
+      timestamp: input.timestamp ?? new Date().toISOString(),
+    });
+    broadcastRuntimeSse("runtime.updated", instance);
+    return instance;
+  }
+
+  function buildWorkstreamSlicePrompt(input: {
+    initiativeTitle: string;
+    initiativeId: string;
+    workstreamId: string;
+    workstreamTitle: string;
+    milestoneSummaries: Array<{ id: string; title: string; status: string }>;
+    taskSummaries: Array<{ id: string; title: string; status: string; milestoneId: string | null }>;
+    executionPolicy: { domain: string; requiredSkills: string[] };
+    runId: string;
+    schemaPath: string;
+  }): string {
+    const milestones = input.milestoneSummaries
+      .map((m) => `- ${m.title} (${m.status}) [${m.id}]`)
+      .slice(0, 10)
+      .join("\n");
+    const tasks = input.taskSummaries
+      .map((t) => {
+        const milestone = t.milestoneId ? ` milestone=${t.milestoneId}` : "";
+        return `- ${t.title} (${t.status}) [${t.id}]${milestone}`;
+      })
+      .slice(0, 18)
+      .join("\n");
+
+    return [
+      `You are an OrgX execution agent running ONE workstream slice in a background codex session.`,
+      ``,
+      `Execution policy: ${input.executionPolicy.domain}`,
+      `Required skills: ${formatRequiredSkills(input.executionPolicy.requiredSkills)}`,
+      ``,
+      `Initiative: ${input.initiativeTitle} [${input.initiativeId}]`,
+      `Workstream: ${input.workstreamTitle} [${input.workstreamId}]`,
+      `Slice run: ${input.runId}`,
+      ``,
+      `Milestones (context):`,
+      milestones || "- (none found)",
+      ``,
+      `Candidate tasks (context only; do NOT assume status is updated unless you explicitly request it in output):`,
+      tasks || "- (none found)",
+      ``,
+      `Reporting (optional but recommended):`,
+      `- You MAY post runtime events for a buttery UX using:`,
+      `  node templates/hooks/scripts/post-reporting-event.mjs --event=task_update --phase=execution --message=\"...\"`,
+      `  (ORGX_RUNTIME_HOOK_URL and ORGX_HOOK_TOKEN are already set in env.)`,
+      ``,
+      `What to do:`,
+      `- Choose a coherent slice of work you can complete end-to-end in this run.`,
+      `- Execute the work (code/docs/config) and produce verifiable outcomes.`,
+      `- If blocked, be explicit about what decision/info is required.`,
+      ``,
+      `Output requirements:`,
+      `- Print ONLY a single JSON object as the final output.`,
+      `- Your JSON MUST conform to this schema file: ${input.schemaPath}`,
+      `- Artifacts must be verifiable: include URLs or local paths, plus verification steps.`,
+      `- If you need a human decision, include it in decisions_needed.`,
+      `- If you are confident OrgX statuses should change, include task_updates and/or milestone_updates (with a short reason).`,
+    ].join("\n");
+  }
+
+  async function registerArtifactSafe(input: {
+    initiativeId: string;
+    runId: string;
+    agentId: string;
+    agentName: string | null;
+    workstreamId: string;
+    artifact: AutoContinueSliceArtifact;
+  }): Promise<{ ok: boolean; id: string | null }> {
+    const now = new Date().toISOString();
+    const name = (input.artifact.name ?? "").trim();
+    if (!name) return { ok: false, id: null };
+    const artifactType = (input.artifact.artifact_type ?? "other").trim() || "other";
+
+    const verificationSteps = Array.isArray(input.artifact.verification_steps)
+      ? input.artifact.verification_steps
+          .filter((step) => typeof step === "string")
+          .map((step) => step.trim())
+          .filter(Boolean)
+      : [];
+
+    const descriptionParts: string[] = [];
+    if (typeof input.artifact.description === "string" && input.artifact.description.trim()) {
+      descriptionParts.push(input.artifact.description.trim());
+    }
+    if (verificationSteps.length > 0) {
+      descriptionParts.push(
+        `Verification:\n${verificationSteps.map((step) => `- ${step}`).join("\n")}`
+      );
+    }
+    const description = descriptionParts.length > 0 ? descriptionParts.join("\n\n") : undefined;
+
+    try {
+      const entity = await client.createEntity("artifact", {
+        initiative_id: input.initiativeId,
+        workstream_id: input.workstreamId,
+        name,
+        artifact_type: artifactType,
+        description,
+        artifact_url: input.artifact.url ?? undefined,
+        status: "active",
+        metadata: {
+          source: "autopilot_slice",
+          run_id: input.runId,
+          milestone_id: input.artifact.milestone_id ?? null,
+          task_ids: input.artifact.task_ids ?? null,
+        },
+      });
+      return { ok: true, id: pickString(entity as any, ["id"]) ?? null };
+    } catch (err: unknown) {
+      try {
+        await appendToOutbox(input.initiativeId, {
+          id: randomUUID(),
+          type: "artifact",
+          timestamp: now,
+          payload: {
+            initiative_id: input.initiativeId,
+            workstream_id: input.workstreamId,
+            name,
+            artifact_type: artifactType,
+            description,
+            url: input.artifact.url ?? undefined,
+            run_id: input.runId,
+          },
+          activityItem: {
+            id: randomUUID(),
+            type: "artifact_created",
+            title: name,
+            description: description ?? null,
+            agentId: input.agentId,
+            agentName: input.agentName,
+            runId: input.runId,
+            initiativeId: input.initiativeId,
+            timestamp: now,
+            phase: "handoff",
+            summary: input.artifact.url ?? null,
+            metadata: {
+              source: "openclaw_local_fallback",
+              event: "autopilot_slice_artifact_buffered",
+              artifact_type: artifactType,
+              url: input.artifact.url ?? null,
+              error: safeErrorMessage(err),
+            },
+          },
+        });
+      } catch {
+        // best effort
+      }
+      return { ok: false, id: null };
+    }
+  }
+
+  async function applyAgentStatusUpdatesSafe(input: {
+    initiativeId: string;
+    runId: string;
+    correlationId: string;
+    taskUpdates: Array<{ task_id: string; status: string; reason?: string | null }>;
+    milestoneUpdates: Array<{ milestone_id: string; status: string; reason?: string | null }>;
+  }): Promise<{ applied: number; buffered: boolean }> {
+    const operations: Array<Record<string, unknown>> = [];
+
+    for (const update of input.taskUpdates) {
+      const taskId = (update?.task_id ?? "").trim();
+      const status = (update?.status ?? "").trim();
+      if (!taskId || !status) continue;
+      operations.push({ op: "task.update", task_id: taskId, status });
+    }
+    for (const update of input.milestoneUpdates) {
+      const milestoneId = (update?.milestone_id ?? "").trim();
+      const status = (update?.status ?? "").trim();
+      if (!milestoneId || !status) continue;
+      operations.push({ op: "milestone.update", milestone_id: milestoneId, status });
+    }
+
+    if (operations.length === 0) return { applied: 0, buffered: false };
+
+    try {
+      await client.applyChangeset({
+        initiative_id: input.initiativeId,
+        run_id: input.runId,
+        correlation_id: input.correlationId,
+        source_client: "openclaw",
+        idempotency_key: idempotencyKey([
+          "openclaw",
+          "autopilot",
+          "slice_status",
+          input.initiativeId,
+          input.runId,
+        ]),
+        operations: operations as any,
+      });
+      return { applied: operations.length, buffered: false };
+    } catch (err: unknown) {
+      const timestamp = new Date().toISOString();
+      try {
+        await appendToOutbox(input.initiativeId, {
+          id: randomUUID(),
+          type: "changeset",
+          timestamp,
+          payload: {
+            initiative_id: input.initiativeId,
+            run_id: input.runId,
+            correlation_id: input.correlationId,
+            source_client: "openclaw",
+            idempotency_key: idempotencyKey([
+              "openclaw",
+              "autopilot",
+              "slice_status",
+              input.initiativeId,
+              input.runId,
+              "outbox",
+            ]),
+            operations,
+          },
+          activityItem: {
+            id: randomUUID(),
+            type: "run_started",
+            title: `Buffered status updates for slice ${input.runId}`,
+            description: null,
+            agentId: null,
+            agentName: null,
+            runId: input.runId,
+            initiativeId: input.initiativeId,
+            timestamp,
+            phase: "review",
+            summary: `Will apply ${operations.length} status update(s) when connected.`,
+            metadata: {
+              source: "openclaw_local_fallback",
+              event: "autopilot_slice_status_updates_buffered",
+              error: safeErrorMessage(err),
+            },
+          },
+        });
+      } catch {
+        // best effort
+      }
+      return { applied: operations.length, buffered: true };
+    }
+  }
+
   async function dispatchFallbackWorkstreamTurn(input: {
     initiativeId: string;
     initiativeTitle: string;
